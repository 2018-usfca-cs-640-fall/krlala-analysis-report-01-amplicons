---
title: "Analysis Report 1: Exploratory data analysis of Fierer dataset "
author: "Karan Lala"
date: "November 12, 2018"
output: github_document
bibliography: references.bib
csl: bioinformatics.csl
---

# Introduction

Bacteria are ubiquitous, and human bodies are no exception. We house millions and billions of bacteria, and have them on the surface of our skin too.
Skin and gut microbiome analysis and the use of relevant data has sharply increased, and entire companies are using these techniques to find solutions
for ailments such as dermatological diseases. While there are many implicated causes for acne,  anaerobic bacterial species *Propionibacterium acnes* is
considered the main culprit in the development of acne.  Infection with the parasitic mite *Demodex* is associated with the development of acne as well.
Informed approaches are being developed to tackle issues such as acne by using microbiome data. By sampling individual's microbiome that do not have acne,
and people that do have acne, may reveal a clear distinguishing factor so much more. Furthermore, that implies that changing the makeup of the microbiome
to a more beneficial community can drive out acne, and similar approaches used to tackle other dermatological issues. The skin microbiota of a healthy
adult may remain stable over time, despite the daily rustle and bustle of life, and so skin microbial communities, if sufficiently unique and identifiable,
can be used a forensic technique.
The microbiome is being studied extensively, and one such paper, Fierer et al, examines whether the microbiota can be used to uniquely identify individuals
using samples from the surfaces they've touched. In this study, computer keys and mice have been used as the aforementioned surfaces. The microbial
communities are examined, and their similarity to the sample source (fingertip) is evaluated and contrasted with the similarity to other fingertips.
The Fierer paper recovers bacterial DNA from surfaces and examines whether it enables sufficient characterization of bacterial communities. For
use in forensics, bacterial communities transferred from a person's skin to surface must persist for days to weeks on the surface, which is also examined.
Pyrosequencing, an NGS ( Next generation sequencing ) method is used to sequence the 16S part of the organisms since it is highly conserved.


In this exploratory data analysis, the metadata and data from the fingertip and keyboard samples are used with phyloseq, DADA2, ggplot2 and dplyr.
The metadata has a lot of information, most which is standard and does not differ across samples. The difference in certain categories, coupled with
the data on the microbial community is used to illustrate data and draw conclusions from it. While the phyloseq data can be used witht he phyloseq object,
it can be melted for use with ggplot2.

Add about 1.5-2 pages here. Must cite at least 10 in peer reviewed articles.

# Methods

Bacterial communities found on individuals fingers were compared with the communities obtained from keys on 3 different keyboards, and keys from a few other keyboards to see how well they matched the fingertip samples in question. Individual keys and the fingertip of the owner were swabbed, and these swabs were stored at -80'C before extracting DNA.

## Sample origin and sequencing

Samples came from computer keys and fingertips.Swabbing of samples was performed using autoclaved cotton-tipped swabs pre-moistened with a sterile solution. DNA collected using “MO BIO PowerSoil” DNA Isolation kit, 16S rRNA genes camplified by PCR. PyroSequencing was then carried out by 454 Life Sciences Genome Sequencer FLX instrument and sequences with less than 200 or more than 300 base pairs were removed from the analysis.


## Computational

These are the methods you used. Should probably be at least a half of a page. At a very minimum should include citations for DADA2 [@callahan2016] and phyloseq [@mcmurdie2013]. Note that these don't count towards the five references you need to cite in the introduction.

# Results

In addition to a minimum of 3-4 figures/tables (and associated captions), you should include sufficient text in this section to describe what your findings were. Remember that in the results section you just describe what you found, but you don't interpret it - that happens in the discussion.

```{r load-libraries, message = FALSE}
# Be sure to install these packages before running this script
# They can be installed either with the intall.packages() function
# or with the 'Packages' pane in RStudio

# load general-use packages
library("dplyr")
library("tidyr")
library("knitr")
library("ggplot2")

# this package allows for the easy inclusion of literature citations in our Rmd
# more info here: https://github.com/crsh/citr
# and here:
# http://rmarkdown.rstudio.com/authoring_bibliographies_and_citations.html
library("citr")

# These are the primary packages well use to clean and analyze the data
# this package needs to be installed from bioconductor -- it's not on CRAN
# see info here: https://benjjneb.github.io/dada2/dada-installation.html
library("dada2")

# This to export a fasta of our final denoised sequence variants
library("seqinr")

# To install this you have to install from GitHub
# See more info here: https://github.com/leffj/mctoolsr
# run this -- install.packages("devtools")
# and then this -- devtools::install_github("leffj/mctoolsr")
library("mctoolsr")

# And this to visualize our results
# it also needs to be installed from bioconductor
library("phyloseq")
```

```{r extract-sample-and-file-names}
# NOTE: Much of the following follows the DADA2 tutorials availablbioe here:
# https://benjjneb.github.io/dada2/tutorial.html
# Accessed October 19, 2017

# set the base path for our input data files
path <- "data/raw_data"

# Sort ensures samples are in order
filenames_forward_reads <- sort(list.files(path, pattern = ".fastq"))

# Extract sample names, assuming filenames have format: SAMPLENAME.fastq
sample_names <- sapply(strsplit(filenames_forward_reads, "\\."), `[`, 1)

# Specify the full path to each of the filenames_forward_reads
filenames_forward_reads <- file.path(path, filenames_forward_reads)
```

```{r check-quality-plots}
# Plots the quality profiles of all twenty samples
plotQualityProfile(filenames_forward_reads[1:20])
```

We can see from the quality profiles that most reads tend to get pretty bad in quality after around 200 bases. 

```{r filter-reads}
# Place filtered files in filtered/ subdirectory
# note this will fail if the directory doesn't exist
filter_path <- file.path("output", "filtered")
filtered_reads_path <- file.path(filter_path,
                                 paste0(sample_names,
                                        "_filt.fastq.gz"))

# See ?filterAndTrim for details on the parameters
# See here for adjustments for 454 data:
# https://benjjneb.github.io/dada2/

filtered_output <- filterAndTrim(fwd = filenames_forward_reads,
                                 filt = filtered_reads_path,
                                 maxLen = 300,
                                 maxN = 0, # discard any seqs with Ns
                                 maxEE = 3, # allow w/ up to 3 expected errors
                                 truncQ = 2, # cut off if quality gets this low
                                 rm.phix = TRUE,
                                 compress = TRUE,
                                 multithread = FALSE)
```

```{r filtered-read-counts-table}
# produce nicely-formatted markdown table of read counts
# before/after trimming
kable(filtered_output,
      col.names = c("Reads In",
                    "Reads Out"))
```

```{r learn-errors}
# this build error models from each of the samples
errors_forward_reads <- learnErrors(filtered_reads_path,
                                    multithread = FALSE)
```

```{r visualize-errors-with-plots}
# quick check to see if error models match data
# (black lines match black points) and are generally decresing left to right
plotErrors(errors_forward_reads,
           nominalQ = TRUE)
```

```{r dereplicate-sequences}
# get rid of any duplicated sequences
dereplicated_forward_reads <- derepFastq(filtered_reads_path,
                                         verbose = TRUE)

# Name the derep-class objects by the sample names
names(dereplicated_forward_reads) <- sample_names
```

```{r run-dada}

dada_forward_reads <- dada(dereplicated_forward_reads,
                           err = errors_forward_reads,
                           HOMOPOLYMER_GAP_PENALTY = -1,
                           BAND_SIZE = 32)

dada_forward_reads
```

```{r make-sequence-table}
# produce the 'site by species matrix'
sequence_table <- makeSequenceTable(dada_forward_reads)
```

The output table has `r nrow(sequence_table)` rows (samples) and `r ncol(sequence_table)` columns (sequence variants). Notice how we can embed R code directly in our markdown text.

```{r histogram-of-sequence-lengths}
# Quick check to look at distribution of trimmed and denoised sequences
hist(nchar(getSequences(sequence_table)),
     main = "Histogram of final sequence variant lengths",
     xlab = "Sequence length in bp")
```

```{r remove-chimeras}
# Check for and remove chimeras
sequence_table_nochim <- removeBimeraDenovo(sequence_table,
                                            method = "consensus",
                                            multithread = FALSE,
                                            verbose = TRUE)

# What percent of our reads are non-chimeric?
non_chimeric_reads <- round(sum(sequence_table_nochim) / sum(sequence_table),
                            digits = 4) * 100
```

After removing chimeras, we were left with `r non_chimeric_reads`% of our cleaned reads.

```{r table-of-pipeline-read-counts}
# Build a table showing how many sequences remain at each step of the pipeline
get_n <- function(x) sum(getUniques(x)) # make a quick function
track <- cbind(filtered_output, # already has 2 columns
               sapply(dada_forward_reads, get_n),
               rowSums(sequence_table),
               rowSums(sequence_table_nochim))

# add nice meaningful column names
colnames(track) <- c("Input",
                     "Filtered",
                     "Denoised",
                     "Sequence Table",
                     "Non-chimeric")

# set the proper rownames
rownames(track) <- sample_names

# produce nice markdown table of progress through the pipeline
kable(track)
```

```{r assign-taxonomy}
# assigns taxonomy to each sequence variant based on a supplied training set
# made up of known sequences
taxa <- assignTaxonomy(sequence_table_nochim,
                       "data/training/rdp_train_set_16.fa.gz",
                       multithread = FALSE,
                       tryRC = TRUE) # also check with seq reverse compliments

# show the results of the taxonomy assignment
unname(taxa)
```

```{r extract-sequences-to-fasta}
# we want to export the cleaned, trimmed, filtered, denoised sequence variants
# so that we can build a phylogeny - we'll build the phylogeny outside of R
# but we need the fasta file to do so. We keep the names of each sequence as the
# sequence itself (which is rather confusing), because that's how DADA2 labels
# it's columns (e.g. 'species')
# function taken from https://github.com/benjjneb/dada2/issues/88
export_taxa_table_and_seqs <- function(sequence_table_nochim,
                                       file_seqtab,
                                       file_seqs) {
  seqtab_t <- as.data.frame(t(sequence_table_nochim)) # transpose to data frame
  seqs <- row.names(seqtab_t) # extract rownames
  row.names(seqtab_t) <- seqs # set rownames to sequences
  outlist <- list(data_loaded = seqtab_t)
  mctoolsr::export_taxa_table(outlist, file_seqtab) # write out an OTU table
  seqs <- as.list(seqs)
  seqinr::write.fasta(seqs, row.names(seqtab_t), file_seqs) # write out fasta
}

# actually run the function, with the names of the files we want it to create
# and where to put them
export_taxa_table_and_seqs(sequence_table_nochim,
                           "output/sequence_variants_table.txt",
                           "output/sequence_variants_seqs.fa")
```


```{r read-in-metadata-and-create-phyloseq}
# Next we want to read in the metadata file so we can add that in too
# This is not a csv file, so we have to use a slightly different syntax
# here the `sep = "\t"` tells the function that the data are tab-delimited
# and the `stringsAsFactors = FALSE` tells it not to assume that things are
# categorical variables
metadata_in <- read.table(paste0("data/metadata/",
                    "fierer_hand_bacteria_SRA_study_ERP022626_SraRunTable.txt"),
                          sep = "\t",
                          header = TRUE,
                          stringsAsFactors = FALSE,
                          row.names = 6) # sets sample IDs to row names

# read in the phylogeny, which was created from the fasta exported above
# in Geneious by aligning the sequences with MAFFT and then building a
# Maximum-Likelihood tree with RAxML
tree_in <- read_tree("output/sequence_variants_MAFFT_FastTree.newick")

# Construct phyloseq object (straightforward from dada2 outputs)
phyloseq_obj <- phyloseq(otu_table(sequence_table_nochim,
                                   taxa_are_rows = FALSE), # sample-spp matrix
                         sample_data(metadata_in), # metadata for each sample
                         tax_table(taxa), # taxonomy for each sequence variant
                         phy_tree(tree_in)) # phylogeny from sequence variants
```

```{r example-phyloseq-plot-1}
# alpha diversity metrics
plot_richness(phyloseq_obj,
              x = "sample_type",
              measures = c("Shannon", "Simpson"),
              color = "Sex") +
  xlab("Sample origin") +
  geom_jitter(width = 0.2) +
  theme_bw()
```

**Figure 1**: Alpha diversity measures of the two sample types, colored by gender.

```{r example-phyloseq-plot-2}
# phylogeny, yay!
plot_tree(phyloseq_obj,
          color = "Sex",
          ladderize = TRUE) # this arranges the tree branches from short to long
```

**Figure 2**: Inferred phylogeny of sequences, with points on tips representing samples within which each particular taxa occurred. Tree represents phylogeny inferred using FastTree.

```{r example-phyloseq-plot-3}

metadata_in %>%
  ggplot(aes(x = host_subject_id, y = sample_source)) +
    geom_point()
```


**Figure 3** : Examination of sample sources and host subjects shows that most of the samples obtained came from individuals M2,M3 and M9.

```{r example-phyloseq-plot-4}


plot_bar(phyloseq_obj,
         x = "Order")
```

**Figure 4** : The abundance of sequence across hosts is visualized, colored for Order. Shows increased presence of Order *Actinomycetales*.

```{r example-phyloseq-plot-5}


plot_bar(phyloseq_obj,
         x = "Family")
```

**Figure 5** : This data shows the distribution of abundance of bacteria by Family, with highest abundance seen in *Propionibacteriaceae*.


```{r example-phyloseq-plot-6}

m9_phyloseq_object <- subset_samples(phyloseq_obj,
                                     host_subject_id == "M9")
plot_bar(m9_phyloseq_object,
         x = "Family")
```

**Figure 6** : This data shows the distribution of abundance of bacteria by Family for one individual, "M9", with highest abundance seen in *Propionibacteriaceae*.

```{r example-phyloseq-plot-7}

l1_phyloseq_object <- subset_samples(phyloseq_obj,
                                     host_subject_id == "L1")
plot_bar(l1_phyloseq_object,
         x = "Family")
```

**Figure 7** : This data shows the distribution of abundance of bacteria by Family for one individual, "L1", with highest abundance seen in *Propionibacteriaceae*.

```{r example-phyloseq-plot-8}
plot_net(phyloseq_obj, maxdist = 0.4, point_label = "host_subject_id",
         color = "host_subject_id", shape = "sample_type")
```

**Figure 8** : Microbiome network representation across samples, and surface type.

```{r example-phyloseq-plot-9}

plot_richness(phyloseq_obj,
              x = "host_subject_id",
              measures = c("Shannon", "Simpson"),
              color = "sample_type") +
  xlab("Sample origin") +
  geom_jitter(width = 0.2) +
  theme_bw()
```





```{r example-phyloseq-plot-10}

spacebar_phyloseq_object <- subset_samples(phyloseq_obj,
                                     sample_source == "Space_bar")
plot_richness(spacebar_phyloseq_object,
              x = "host_subject_id",
              measures = c("Shannon", "Simpson"),
              color = "sample_type") +
  xlab("Sample origin") +
  geom_jitter(width = 0.2) +
  theme_bw()
```



# Discussion

Add around 2-3 pages interpreting your results and considering future directions one might take in analyzing these data.

# Sources Cited


